\cleardoublepage


\chapter{Pfadplanung}\label{ch:pfadplanung}

Bei der Pfadplanung geht es darum, eine Reihe an Konfigurationen zu berechnen, die den Weg von einer bestimmten Transformation in eine andere beschreiben.
Eine einzelne Konfiguration ist im Falle des UR5 ein Tupel mit sechs Winkeln, die die Ausrichtung der sechs Gelenke des Roboters beschreiben.

Die einfachste Form der Pfadplanung ist der kürzeste Weg zwischen zwei Punkten (Abschnitt~\ref{subsec:kurzester-weg}), die schnellste Verbindung ist immer der Weg der direkten Kinematik mit maximaler Winkelgeschwindigkeit bei der Bewegung (Abschnitt~\ref{ch:direkte-kinematik}).
Komplizierter wird es, wenn Beschränkungen im Arbeitsraum des Roboters, wie Kollisionen mit der Umgebung oder mit sich selbst, vorliegen.
In diesem Fall muss ein komplizierteres Berechnungsverfahren herangezogen werden.

In diesem Kapitel sollen die Grundlagen der Pfadplanung, sowie einige Algorithmen näher vorgestellt werden.


\section{Konfigurationsraum}\label{sec:konfigurationsraum}


Der Konfigurationsraum $\mathit{C}$ stellt die Grundlage für die Algorithmen in der Pfadplanung dar und beschreibt alle möglichen Konfigurationen, die der Roboter einnehmen kann.
Eine Konfiguration des UR5 ist dabei wie in Gleichung~\ref{eq:config-1} definiert, wobei die Winkelwerte $\theta_i$ durch ihre Maximal- und Minimalwerte des Datenblatts~\cite{universalrobotsUR5TechnicalSpecifications} von $\pm 360^{\circ}$ beschränkt sind.
Gleichsam existieren Konfigurationen innerhalb dieser Menge $\mathit{O}\in\mathit{C}$, die Kollisionen beschreiben.
Darunter zählen Konfigurationen, bei denen sich der Roboter selbst im Weg steht, sowie welche, bei denen der Untergrund oder statische Hindernisse eine erfolgreiche Ausführung der Bewegung verhindern.
Der für die Pfadplanung relevante Bereich ist demzufolge der in Gleichung~\ref{eq:config-2} beschriebene Menge $\mathit{C}_{free}$, der freie Konfigurationsraum, dessen Konfigurationen den Bereich beschreiben, durch den Roboter sich bewegen kann.

\begin{equation}
    \mathit{C} = \left\{ \left( \theta_1,\dots,\theta_6 \right) \in \theta_1\times\dots\times\theta_6 \mid \theta_i \in \left[ -2\pi, 2\pi \right]\right\}
    \label{eq:config-1}
\end{equation}
\begin{equation}
    \mathit{C}_{free} = \mathit{C}\backslash\mathit{O}
    \label{eq:config-2}
\end{equation}

Je nach Algorithmus muss der Konfigurationsraum allerdings nicht im vorhinein berechnet werden.
Um den Kollisionsraum abzubilden wurde der Roboter in dieser Arbeit mit Kugeln und Zylindern in den Dimensionen des UR5 approximiert und in fünf-Grad Schritten jede Position auf Eigenkollision getestet, damit Pfadplanungsalgorithmen schneller auf ihre Funktionsweise hin untersucht werden können.

?? Code

??Quelle

% todo berechnung/beschreibung von collision detection mit bb / trees
https://www.geometrictools.com/Documentation/DynamicCollisionDetection.pdf


\section{Berechnungsmethoden}

\subsection{Kürzester Weg}\label{subsec:kurzester-weg}

In dieser Berechnungsmethode werden Position und Orientierung des Endeffektors linear zwischen zwei oder mehr Transformationen $T_1$ und $T_2$ verändert.
Für die Translation zwischen $P_1$ und $P_2$ kann für jeden Schritt ein Faktor $t \in \left[0,1\right]$ multipliziert werden (Gleichung~\ref{eq:shortest-path-1}).
Zwischen zwei Rotationen $R_1$ und $R_2$ wird in der Regel der sog.\ Slerp verwendet (Gleichung~\ref{eq:shortest-path-2}).
Dabei müssen die Rotationen der allerdings erst in Quaternionen $Q_1$ und $Q_2$ umgerechnet werden.
Zu beachten sind zudem die Rechenregeln der Quaternionen, die hier nicht näher erklärt werden.

\begin{equation}
    P_{t} = P_0 + \left( P_1 - P_0 \right) \cdot t
    \label{eq:shortest-path-1}
\end{equation}
\begin{equation}
    Q_{t} = Q_1 \cdot \left( Q_1^{-1} \cdot Q_2 \right)^t
    \label{eq:shortest-path-2}
\end{equation}

?? Quelle

\subsection{Zellendekomposition}\label{subsec:zellendekomposition}
?? Quelle

In der Zellendekomposition wird der freie Konfigurationsraum $C_{free}$ in kleinere Felder, sog.\ Zellen unterteilt.
Zwei Konfigurationen liegen genau dann in der gleichen Zelle, falls ein Übergang zwischen den beiden Zuständen kollisionsfrei möglich ist und zwei benachbarte Zellen müssen über einen einfachen Pfad miteinander kollisionsfrei verbunden sein.
Dies setzt konvexe Zellen voraus, bei denen jeder Punkt innerhalb der Zelle jeden anderen erreichen kann.
Auf Basis dieser Gruppierungen kann dann ein Konnektivitätsgraph oder eine Roadmap erstellt werden.

Diese direkte Berechnung der Zellenstruktur ist im sechsdimensionalen Fall des UR5 allerdings nichttrival und aufwändig.
Aus diesem Grund und für die schnellere Berechnung wird deshalb oftmals eine approximierte Lösung bevorzugt.
Dazu kann ein kd-Tree verwendet werden, der ein Konfigurationsraum als Baum so abbildet, dass Abstände und benachbarte Zellen zügig berechnet werden können.
Im zweidimensionalen Raum werden hierfür die Positionen und Dimensionen von Quadraten sowie dessen Nachbarn gespeichert.

\subsection{Sampling-Verfahren}
?? Quelle

In Sampling-basierten Verfahren wird das Erstellen einer Datenstruktur, die das Problem vollständig abdeckt, übersprungen und stattdessen nur einzelne, benötigte Konfigurationen auf Kollision geprüft.
Das bedeutet, dass nicht, wie in Abschnitt~\ref{subsec:zellendekomposition} alle Lösungen für alle Probleme generalisiert werden sollen, sondern eine einzelne Lösung für ein einzelnes Problem gesucht ist.
Bedingung dafür ist allerdings eine Möglichkeit, eine Konfiguration schnell auf Kollisionsfreiheit zu überprüfen.
Insofern der Konfigurationsraum wie in Abschnitt~\ref{sec:konfigurationsraum} schon zuvor berechnet wurde, kann alternativ ein Lookup-Table verwendet werden.
Dabei kann zwischen Single- und Multi-Query-Verfahren unterschieden werden.

Bei Single-Query-Verfahren wird für jede Abfrage ein neuer Weg gesucht, bei Multi-Query-Verfahren werden vergangene Anfragen als Hilfestellung für neue Anfragen genutzt und so eine Roadmap erzeugt.
Üblicherweise wird beim Single-Query-Verfahren mit Startkonfiguration $q_a$ und Zielkonfiguration $q_b$ wie folgt vorgegangen:
\begin{enumerate}
    \item Initalisierung eines Graphens $G(V, E)$ mit Knoten mit $V=\left\{ q_a, q_b \right\}$ und $E=\left\{  \right\}$
    \item Auswahl eines Expansionsknotens aus $V$ mit einem gewählten Algorithmus
    \item Berechnung eines neuen Knotens und einer Kante mit einem gewählten Algorithmus (inklusive Kollisionsüberprüfung)
    \item Erweiterung des Graphens mit zuvor gefundenem Knoten und neuer Kante (falls möglich).
    \item Prüfe auf Lösung in G (Verbindung von Start und Zielknoten) oder wiederhole ab 2.
\end{enumerate}

Single-Query
Unidirektional vs. Bidirektional
RRT
biased / unbiased to exploration
Q-space muss nicht vollständig bekannt sein
RRT*
Multi-Query
Probabilistic Roadmaps
Potentialfeldmethode / Gradientenverfahren
Genetische Algorithmen


\section{Constraints und Praxisbezug}
Kinematisch (Winkelbegrenzung)
Dynamisch (Geschwindigkeit)
Einbezug der Constraints in den Algorithmen
Praxis: OMPL (MoveIt+ ROS / Copelliasim Plugin)

