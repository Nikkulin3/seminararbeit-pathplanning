\cleardoublepage


\chapter{Pfadplanung}\label{ch:pfadplanung}

Bei der Pfadplanung geht es darum, eine Reihe an Konfigurationen zu berechnen, die den Weg von einer bestimmten Transformation in eine andere beschreiben.
Eine einzelne Konfiguration ist im Falle des UR5 ein Tupel mit sechs Winkeln, die die Ausrichtung der sechs Gelenke des Roboters beschreiben.

Die einfachste Form der Pfadplanung ist der kürzeste Weg zwischen zwei Punkten (Abschnitt~\ref{subsec:kurzester-weg}), die schnellste Verbindung ist immer der Weg der direkten Kinematik mit maximaler Winkelgeschwindigkeit bei der Bewegung (Abschnitt~\ref{ch:direkte-kinematik}).
Komplizierter wird es, wenn Beschränkungen im Arbeitsraum des Roboters, wie Kollisionen mit der Umgebung oder mit sich selbst, vorliegen.
In diesem Fall muss ein komplizierteres Berechnungsverfahren herangezogen werden.

In diesem Kapitel sollen die Grundlagen der Pfadplanung, sowie einige Algorithmen näher vorgestellt werden.


\section{Konfigurationsraum}\label{sec:konfigurationsraum}


Der Konfigurationsraum $\mathit{C}$ stellt die Grundlage für die Algorithmen in der Pfadplanung dar und beschreibt alle möglichen Konfigurationen, die der Roboter einnehmen kann.
Eine Konfiguration des UR5 ist dabei wie in Gleichung~\ref{eq:config-1} definiert, wobei die Winkelwerte $\theta_i$ durch ihre Maximal- und Minimalwerte des Datenblatts~\cite{universalrobotsUR5TechnicalSpecifications} von $\pm 360^{\circ}$ beschränkt sind.
Gleichsam existieren Konfigurationen innerhalb dieser Menge $\mathit{O}\in\mathit{C}$, die Kollisionen beschreiben.
Darunter zählen Konfigurationen, bei denen sich der Roboter selbst im Weg steht, sowie welche, bei denen der Untergrund oder statische Hindernisse eine erfolgreiche Ausführung der Bewegung verhindern.
Der für die Pfadplanung relevante Bereich ist demzufolge der in Gleichung~\ref{eq:config-2} beschriebene Menge $\mathit{C}_{free}$, der freie Konfigurationsraum, dessen Konfigurationen den Bereich beschreiben, durch den Roboter sich bewegen kann.

\begin{equation}
    \mathit{C} = \left\{ \left( \theta_1,\dots,\theta_6 \right) \in \theta_1\times\dots\times\theta_6 \mid \theta_i \in \left[ -2\pi, 2\pi \right]\right\}
    \label{eq:config-1}
\end{equation}
\begin{equation}
    \mathit{C}_{free} = \mathit{C}\backslash\mathit{O}
    \label{eq:config-2}
\end{equation}

Je nach Algorithmus muss der Konfigurationsraum allerdings nicht im vorhinein berechnet werden.
Um den Kollisionsraum abzubilden wurde der Roboter in dieser Arbeit mit Kugeln und Zylindern in den Dimensionen des UR5 approximiert und in fünf-Grad Schritten jede Position auf Eigenkollision getestet, damit Pfadplanungsalgorithmen schneller auf ihre Funktionsweise hin untersucht werden können.

?? Code

??Quelle

% todo berechnung/beschreibung von collision detection mit bb / trees
https://www.geometrictools.com/Documentation/DynamicCollisionDetection.pdf


\section{Berechnungsmethoden}
%
%\subsection{Kürzester Weg}\label{subsec:kurzester-weg}
Im einfachsten Fall soll der Roboter auf kürzestem Weg in eine Zielposition fahren.
Dabei wird die Wegstrecke meist linear in mehrere Zwischentransformationen zwischen zwei oder mehr Transformationen $T_1$ und $T_2$ aufgeteilt.
Für die Translation von Punkt $P_1$ und Punkt $P_2$ kann für jeden Schritt ein Faktor $t \in \left[0,1\right]$ multipliziert werden (Gleichung~\ref{eq:shortest-path-1}).
Zwischen zwei Rotationen $R_1$ und $R_2$ wird in der Regel der sog.\ Slerp verwendet (Gleichung~\ref{eq:shortest-path-2}).
Dabei müssen die Rotationen der allerdings erst in Quaternionen $Q_1$ und $Q_2$ umgerechnet werden.
Zu beachten sind zudem die Rechenregeln der Quaternionen, die hier nicht näher erklärt werden.

\begin{equation}
    P_{t} = P_0 + \left( P_1 - P_0 \right) \cdot t
    \label{eq:shortest-path-1}
\end{equation}
\begin{equation}
    Q_{t} = Q_1 \cdot \left( Q_1^{-1} \cdot Q_2 \right)^t
    \label{eq:shortest-path-2}
\end{equation}

Die resultierende Liste an Endeffektor-Transformationen muss dann in den Konfigurationsraum des Roboters übersetzt werden.
Beim UR5 gibt es, wie in Abschnitt~\ref{sec:geometrische-losung} berechnet, für jede Zwischentransformation oftmals bis zu acht, oder in einer Singularität sogar unendlich viele Stellungen für die Gelenke.
Um einen geeigneten Pfad durch den Konfigurationsraum zu nehmen und die Selbstkollision sowie das Erreichen von Winkelbegrenzungen zu vermeiden, sollte deshalb ein Pfadplanungsalgorithmus zu Hilfe genommen werden.

?? Quelle

\subsection{Zellendekomposition}\label{subsec:zellendekomposition}
?? Quelle

In der Zellendekomposition wird der freie Konfigurationsraum $C_{free}$ in kleinere Felder, sog.\ Zellen unterteilt.
Zwei Konfigurationen liegen genau dann in der gleichen Zelle, falls ein Übergang zwischen den beiden Zuständen kollisionsfrei möglich ist und zwei benachbarte Zellen müssen über einen einfachen Pfad miteinander kollisionsfrei verbunden sein.
Dies setzt konvexe Zellen voraus, bei denen jeder Punkt innerhalb der Zelle jeden anderen erreichen kann.
Auf Basis dieser Gruppierungen kann dann ein Konnektivitätsgraph oder eine Roadmap erstellt werden.
Als Datenstruktur kann ein KD-Tree verwendet werden, der ein Konfigurationsraum als Baum so abbildet, dass Abstände und benachbarte Zellen zügig berechnet werden können.
Im zweidimensionalen Raum werden hierfür die Positionen und Dimensionen von Quadraten sowie dessen Nachbarn gespeichert.

Diese direkte Berechnung der Zellenstruktur ist im sechsdimensionalen Fall des UR5 allerdings nichttrival und aufwändig.
Aus diesem Grund und für die schnellere Berechnung wird deshalb oftmals eine approximierte Lösung aus einem Sampling-Verfahren bevorzugt.

\subsection{Sampling-Verfahren}
?? Quelle

In Sampling-basierten Verfahren wird das Gruppieren aller Konfigurationen in konkave Zellen übersprungen und stattdessen nur einzelne, benötigte Konfigurationen auf Kollision geprüft.
Das bedeutet, dass nicht, wie in Abschnitt~\ref{subsec:zellendekomposition} alle Lösungen für alle Probleme generalisiert werden sollen, sondern eine einzelne Lösung für ein einzelnes Problem gesucht ist.
Bedingung dafür ist allerdings eine Möglichkeit, eine Konfiguration schnell auf Kollisionsfreiheit zu überprüfen.
Insofern der Konfigurationsraum wie in Abschnitt~\ref{sec:konfigurationsraum} schon zuvor berechnet wurde, kann alternativ ein Lookup-Table verwendet werden.
Dabei kann zwischen Single- und Multi-Query-Verfahren unterschieden werden.

\subsubsection{Single-Query}

Bei Single-Query-Verfahren wird für jede Abfrage ein neuer Weg gesucht, bei Multi-Query-Verfahren werden vergangene Anfragen als Hilfestellung für neue Anfragen genutzt und so eine Roadmap erzeugt.
Üblicherweise wird beim Single-Query-Verfahren mit Startkonfiguration $q_a$ und Zielkonfiguration $q_b$ wie folgt vorgegangen:
\begin{enumerate}
    \item Initalisierung eines Graphens $G(V, E)$ mit Knoten mit $V=\left\{ q_a, q_b \right\}$ und $E=\left\{  \right\}$
    \item Auswahl eines Expansionsknotens aus $V$ mit einem gewählten Algorithmus
    \item Berechnung eines neuen Knotens und einer Kante mit einem gewählten Algorithmus (inklusive Kollisionsüberprüfung)
    \item Erweiterung des Graphens mit zuvor gefundenem Knoten und neuer Kante (falls möglich).
    \item Prüfe auf Lösung in G (Verbindung von Start und Zielknoten) oder wiederhole ab 2.
\end{enumerate}

Zudem kann der Algorithmus auf zwei oder mehr Suchbäume ausgeweitet werden, die sich nach einiger Zeit in der Mitte treffen.
Dazu wird dann in den Schritten 2\-4 der verwendete Baum zufällig ausgewählt.

Der \ac{rrt} ist ein häufig verwendeter Suchbaum in diesem Kontext.
Hier wird zunächst wie in 3.\ eine neue Konfiguration zufällig gewählt und ab dem nächsten Knoten im Graphen eine Schrittweite in Richtung dieser Konfiguration gegangen.
Um einen Bias gegenüber der Zielkonfiguration zu erzeugen, kann zudem mit einer gewissen Wahrscheinlichkeit der zufällig gewählte Knoten mit dem tatsächlichen Zielknoten ersetzt werden.
Bei RRT$^*$ wird bei der Erweiterung zusätzlich auf andere Verbindungen des Graphens zum neu berechneten Knoten geprüft, was die Länge der kürzesten Verbindung zwischen Start und Ziel noch einmal minimiert.
Die kürzeste Verbindung kann beispielsweise mithilfe von A$^*$ oder Dijkstra ermittelt werden.

\subsubsection{Multi-Query}
Bei Multi-Query Verfahren können bereits berechnete Kanten des aufgebauten Graphens wiederverwendet werden.
Im Probabilistic-Roadmap-Algorithmus werden in einem ersten Schritt n zufällige Knotenpunkte erzeugt und dann mit ihren nächsten Nachbarn verbunden, insofern keine Kollision vorliegt.
Im Anschluss werden Start- und Zielknoten ergänzt und ebenfalls Nachbarn als Kanten im Graphen hinzugefügt.
Am Ende kann dann wieder mithilfe von A$^*$ oder Dijkstra ein kürzester Weg ermittelt werden.


??

%Single-Query
%Unidirektional vs.\ Bidirektional
%RRT
%biased / unbiased to exploration
%Q-space muss nicht vollständig bekannt sein
%RRT*
%Multi-Query
%Probabilistic Roadmaps
Potentialfeldmethode / Gradientenverfahren
Genetische Algorithmen


\section{Constraints und Praxisbezug}
Kinematisch (Winkelbegrenzung)
Dynamisch (Geschwindigkeit)
Einbezug der Constraints in den Algorithmen
Praxis: OMPL (MoveIt+ ROS / Copelliasim Plugin)

